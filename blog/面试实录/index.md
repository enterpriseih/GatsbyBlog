---
title: 面试实录
categories:
  - 面试
path: /interview-record/
tags: 面试, 面试实录
date: 2020-6-4 23:34:08
draft: true
---

# 腾讯

这里是 SNG 部门的面试

## 一面

今天晚上 7 点左右接到腾讯 SNG 打来的电话，全长 40 分钟

1. 简要介绍自己
2. 客服系统采用什么架构？
3. Ionic框架是做什么的？
4. Ionic前身是解决什么问题的？
5. 客服系统为什么采用这个框架？为了移动端PC端代码的一次编写，美工不足
6. websocket怎么实现的？还有什么别的方式来实现消息推送机制？
7. 当时用的Angular的版本？双向绑定是怎么实现的？
8. 301与302的区别？
9. jquery中bind和on的用法？以及他们的区别？优缺点？
10. 商家后台技术栈？react是什么东西？react虚拟dom算法的实现方式？虚拟dom是什么？
11. 重绘与重排是什么？他们的区别？有一个动画怎样实现使它的dom的重排重绘改变最小？也就是更流畅？
12. 什么是一级dom和二级dom？
13. 什么是事件委托？
14. 跨域的几种实现方式？其中postMessage内部的实现方式？调用过程？伪装域名怎么解决？其中服务器端怎么实现Access-Control-Allow-Origin的跨域的（怎么拦截跨域的）？
15. 浏览器事件规则的传递？
16. 缓存的实现方式？
17. dns的查询过程？
18. 你怎么称呼？
19. 你主要做什么业务？
20. 有没有涉及到后台运营一些业务？

以上更新于`2018-04-23 19:44:37`

---

# SHEIN

## 一面

1. react v15 与 v16 的主要变化？
2. react v15 getChildContext 与 react v16 Context.Provider 优缺点？
3. redux 与 mobx 的优缺点？
4. 组件怎么做性能优化？
5. mobx 怎么做性能优化？
6. table 的某一行有很多组件，使用起来卡顿，怎么优化？
7. webpack v2 升级到 webpack v4 你主要做了哪些优化？
8. 页面性能优化？
9. react 页面白屏的原因及解决方法？
10. react 中全局主题色怎么配置？
11. style 与 className 那种更好？
12. react 组件最耗性能的地方？怎么优化
13. 面试需要几轮？
14. 面试官是做什么业务的？

## 二面

1. 介绍自己
2. 有没有女朋友
3. 工作经历中隔了一年是什么原因
4. 为什么跳槽
5. 为什么要选你
6. 页面上有图片加载，图片有懒加载，如何计算图片曝光性能更好
7. 根据上面的条件，除了图片曝光信息之外，还有浏览器上有一些数据要采集，如何发给后端？
8. 架构组主要做些什么
9. 上线的流程怎么样

以上更新于`2020-5-20 09:17:01`

---

# 数字广东（拿到 offer）

## 一面

1. 输入网址浏览器执行的过程
2. TCP 连接时为什么三次握手
3. TCP 断开时为什么四次挥手
4. vue 用法？
5. react 16 与 15 的区别
6. 为什么要加上 react 16 的生命周期？
7. fiber 原理？底层架构
8. webpack 原理
9. webpack 分包机制？webpack 4 与 2 的分包机制有什么区别？
10. 网页性能优化
11. 图片格式的选择？
12. 拿到美工的图片时会怎么选择？做什么处理？
13. iconfont 字体库原理？
14. css 选择器优先级？
15. 对方技术栈？
16. 对方面试几轮？
17. 对方做什么业务？

以上更新于`2020-5-27 13:34:46`

---

## 二面

1. 项目介绍？
2. 如果遇到UI和你的意见不一致你会怎么处理？
3. 对方的技术栈？
4. 对方的上线流程？
5. 对方的架构工作？

## 三面

1. 怎么做组件的复用
2. 项目介绍

# 腾讯

这里是开发平台运营前端的面试

## 一面

1. 项目介绍？
2. 浏览器缓存介绍？
3. sw缓存怎么实现的？原理是什么？
4. sw缓存机制是否有了解？如何更新sw缓存？
5. https原理？中途被篡改的话该怎么预防？
6. 代码劫持实现XMLHttpRequest Send方法，要求每个ajax请求把请求参数打印出来？
7. 叙述一下js事件的处理机制？
8. 实现一段程序，检测括号是否成对出现？例如`(())()`
9. 实现一个sum函数，要求：`sum(1, 2).result = 3;sum(1, 2)(3).result = 6;sum(1, 2)(3, 4).result = 10;sum(1, 2)(3, 4)(5).result = 15`
10. 求字符串的最长公共前缀，例如输入：`["flower", "flow", "flight"]`，输出：`fl`

以上更新于`2020-6-2 00:17:38`

---

# 晓教育

## 一面

1. 冒泡排序与选择排序的区别？
2. BFC与IFC？
3. react生命周期？
4. 移动端适配的点？
5. 移动端像素的适配做过没？rem 转 px 之类的方案？
6. webpack pc/mobile 是怎么多渠道打包的？
7. 怎么加速 webpack 的构建？
8. 微前端有做过吗？讲下实践过程及原理？
9. websocket做过吗？有自己写过的socket库吗？

# 青鹿教育

## 二面

1. 个人介绍？
2. 项目介绍？
3. 你搭建的脚手架或者说技术方案会带来什么商业价值？说实话不清楚，这方面需要多加思考
4. 负责产品的用户规模？
5. 未来规划？
6. 你如何达到前端架构师/架构师的高度？需要架构、后端的知识，大规模业务下的锤炼、熟练业务设计出符合业务的架构、多多考虑商业价值
7. 如果带人你会怎么去带人？以身作责、技术分享、教他们做事的方法

## 三面

1. 期望薪资？
2. 未来期望？
3. 来到这个团队希望担任的角色？

# 腾讯

这里是 QQ 邮箱架构组前端的面试

## 一面

1. 合并两个升序链表。比如：L1={1, 3, 5}, L2={2, 4}, L1.merge(L2)后，L1={1, 2, 3, 4, 5}

```js
/**
 * function LinkNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 *
 * @param {LinkNode} headL2
 */
LinkNode.prototype.merge = function (headL2) {

}
```

2. 给定一个递增的循环数组，从里面找出最小的元素。比如：[50, 52, 63, 90, 3, 8, 15, 44]，最小元素为3，要求时间复杂度尽可能小。

```js
/**
 * @param {number[]} nums
 * @returns {number}
 */
const findmin = function (nums) {

}
```

3. 找出二叉排序树中第3大的节点，要求空间复杂度为O(1)。

```js
/**
* function TreeNode(value) {
*     this.value = value
*     this.left = null
*     this.right = null
* }
*
*
* @param {TreeNode} root
* @returns {number}
*/
const find = function (root) {

}
```

4. 完成函数inherit，使得函数Child继承函数Parent，这里的子类为什么能访问到父类中的变量a？

```js
/**
* function Parent() {
*     this.a = 'a'
* }
*
* function Child() {
*     Parent.call(this)
*     this.b = 'b'
* }
*
* inherit(Child, Parent)
*/
const inherit = function (a, b) {
  a.prototype = Object.create(b.prototype);
  a.prototype.constructor = a;
}
```

5. 将一个带 callback 参数的函数 promise 化

```js
/**
* const callbackFunc = function (callback) {
*     callback()
* }
*
* promisify(callbackFunc).call(this).then(() => {
*     // after callback() called
* })
*/
function promisify(original) {

}
```

6. 项目难点介绍
7. 微前端是什么？解决什么问题？
8. https原理？如果中间人伪造了权威机构的 ca 证书的话，有什么办法解决？

每年都会有 CA 评级，把垃圾 CA 加入到操作系统的 untrusted root 列表或者从 Firefox 中移除

9. 兼容性平时怎么做的？做过一体化的解决方法没？类似于 polyfill
10. 对方人员构成？8 个人左右，都是轮流负责任务，没有专人负责某一块的说法
11. 对方技术栈？老的都是用原生的，新的用 vue

# 头条

## 一面

1. 写出执行结果

```js
function a() {
    console.log('a');
    Promise.resolve().then(() => {
      console.log('e');
    });
}

function b() {
    console.log('b');
}

function c() {
  console.log('c');
}

function d() {
    setTimeout(a, 0);
    var temp = Promise.resolve().then(b);
    setTimeout(c, 0);
    console.log('d');
}
d();
```

d b a e c

2. 实现以下函数，失败时重试次数为 retryTime，延时执行的时间 delay

fetchTry(url, retryTime, delay)

3. 实现一个函数 add 3 个数相加， add(1, 2, 3), add(1)(2)(3), add(1, 2)(3) add(1)(2,3) 都返回6

```js
function add() {
  const args = [...arguments];
  function fn() {
    return add.apply(null, [...args, ...arguments]);
  }
  fn.toString = function() {
    return args.reduce((sum, item) => sum + item, 0);
  }
  return fn;
}
```

4. react fiber 架构，如何实现不影响 ui 主线程并顺序更新？
5. async 如何实现 promise？
6. redux 结构怎样？api 有哪些？写过 redux 中间件吗？connect 原理？

中间件源码

```js
export default function applyMiddleware(...middlewares) {
  return createStore => (...args) => {
    // 利用传入的 createStore 和 reducer 和创建一个 store
    const store = createStore(...args);
    let dispatch = () => {
      throw new Error(
      )
    };
    const middlewareAPI = {
      getState: store.getState,
      dispatch: (...args) => dispatch(...args),
    }
    // 让每个 middleware 带着 middlewareAPI 这个参数分别执行一遍
    const chain = middlewares.map(middleware => middleware(middlewareAPI));
    // 接着 compose 将 chain 中的所有匿名函数，组装成一个新的函数，即新的 dispatch
    dispatch = compose(...chain)(store.dispatch);
    return {
      ...store,
      dispatch,
    }
  }
}
```

redux-thunk

```js
function createThunkMiddleware(extraArgument) {
  return ({ dispatch, getState }) => next => action => {
    if (typeof action === 'function') {
      return action(dispatch, getState, extraArgument);
    }
    return next(action);
  };
}
const thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;
export default thunk;
```

redux-promise

```js
import { isFSA } from 'flux-standard-action';

function isPromise(val) {
  return val && typeof val.then === 'function';
}

export default function promiseMiddleware({ dispatch }) {
  return next => action => {
    if (!isFSA(action)) {
      return isPromise(action)
        ? action.then(dispatch)
        : next(action);
    }

    return isPromise(action.payload)
      ? action.payload.then(
          result => dispatch({ ...action, payload: result }),
          error => {
            dispatch({ ...action, payload: error, error: true });
            return Promise.reject(error);
          }
        )
      : next(action);
  };
}
```

7. webpack 加速构建？
8. webpack 的 loader、plugin 是什么？写过 plugin 吗？

```js
// A JavaScript class.
class MyExampleWebpackPlugin {
  // Define `apply` as its prototype method which is supplied with compiler as its argument
  apply(compiler) {
    // Specify the event hook to attach to
    compiler.hooks.emit.tapAsync(
      'MyExampleWebpackPlugin',
      (compilation, callback) => {
        console.log('This is an example plugin!');
        console.log('Here’s the `compilation` object which represents a single build of assets:', compilation);

        // Manipulate the build using the plugin API provided by webpack
        compilation.addModule(/* ... */);

        callback();
      }
    );
  }
}
```

一个 webpack 插件的基本模式包括几个要素：类名、apply 方法、event hook、compilation 的处理和 hook type 及其回调处理。

apply 方法是必须有的，因为 webpack 运行的时候会调用 plugin 实例的 apply 方法。

compiler 可以理解为全局的 webpack 实例，webpack 在生命周期的不同阶段提供了不同的钩子，方便我们自定义 webpack 打包的行为。

compliation 是 webpack 要进行处理的资源（js、css、html 等），我们可以根据自己的需要对资源进行加工。

在上面，tapAsync 是 hook type 的一种，第一个参数一般跟插件的类名一样，主要用来区分在该 hook type 上定义的不同的回调行为。

`event hook`

webpack plugin 的 event hook 很多，如：entryOption，run，compile，make，emit，done等等。具体可以参照官方文档，这里不一一介绍。这些钩子在 webpack 编译的不同阶段会依次触发，开发插件的时候只要选择自己需要的钩子做处理就可以了。

`hook type`

webpack 的事件机制是基于 tapable 这个库实现的，tapable 的具体使用方式可以参考它的 README。

开发 webpack plugin 主要用到的 hook type 是：tap（同步），tapAsync（异步，回调写法），tapPromise（异步，Promise 写法）

# 晓教育

## 二面

1. app 冷启动怎样更快

常用的加速方法

通常的 web 优化方法，基本围绕在资源加载和 html 渲染两个方面。前者针对首屏，后者针对可交互。

资源优化上，我们总的方向是围绕更小的资源包上，比如常见的：压缩、减包、拆包、动态加载包及图片优化上。html 渲染上总的方向是更快的展示内容，比如通过 cdn 分发、dns 解析、http 缓存、数据预请求，数据缓存及首屏优化大杀器——直出等。

- 直出 + 离线包缓存：通过 webview 统一拦截 url，将资源映射到本地离线包，更新的时候对版本资源检测，下载和维护本地缓存目录中的资源，比如腾讯的 webso 和 Alloykit 的离线包方案
- 客户端代理的 VasSonic：webview 初始化和通过客户端代理资源请求并行、流式拦截请求，边加载边渲染、实现了动态缓存和增量更新（定义了一套 html 注释标记规则，通过标签划分哪些是动态数据，后端根据传过来的页面内容的 ID 来判断是否更新，然后进行 html 拼接返回给前端）。
- PWA+直出+预加载：对于直出 html，我们可以配合 pwa，将从后台直出的文件，缓存到 cacheStorage，在下一次请求时，优先从本地缓存中获取，同时发起网络请求更新本地 html 文件；但是在 hybrid 的 h5 应用，第一次启动的加载资源仍然费时，我们可以通过 app 端上支持预加载一个 javascript 脚本，拉取需要 PWA 缓存的页面，可以提前完成缓存。
- NSR 渲染：前端版本的 SSR，借助浏览器启用一个 JS-Runtime，提前将下载好的 html 模板及预取的 feed 流数据进行渲染，然后将 html 设置到内存级别的 MemoryCache 中，从而达到点开即看的效果。
- 客户端 PWA：service-worker 在 webview 实现性能并没有想象中好。在某项目下掉 sw 后，整体大盘访问速度整体反而提升上升了大概 300ms，需要自行实现。
- 小程序化：通过在架构上对开发进行规范化和约束化，小程序内部将 webview 渲染和 js 执行分离开来，然后通过离线包，页面拆分，预加载页面等一系列优化手段，让小程序天然具备了大量的 H5 优化后的效果，其代价是牺牲了 web 的灵活性。

总的思路是

- 在整个链路中减少中间环节。比如将串行改并行，包括小程序内部执行机制。
- 尽可能的预加载、预执行。比如从数据预取，到页面预取渲染等。

以上方案仍有两种无法尽善尽美的地方：其一是短暂的白屏现象不可避免，其二是对于超大型 web 应用难以做到秒开

无论是 html 离线，还是直出，以及让 webview 启动和网络请求并行 ，页面的切换和打开都无法避免 html 加载这一过程。对于大型应用而言，庞大的 js 初始化解析和执行会耗费巨大的时间。

让 webview 组件及其容器内的 html 页面常驻，在文档切换的过程，仅仅对数据进行替换，这即是容器化方案。

支持容器化的前提是：需要对代码改造成可支持数据组装和销毁。

- 依赖倒置：越稳定不变逻辑，应该是越底层，越接近用户交互，容易变化的部分是上层。具体层级划分需要分析应用的结构和依赖关系，良好划分层级的应用是容器化改造的前提
- 职责链模式：职责链模式是指每个对象都有接受请求的可能，这些对象连接成一条链，请求沿着这条链的传递，直到有对象处理，这样做的好处是减少接受者和发送者直接的耦合。比如在一个页面加载生命周期中，我们可以让内部模块到外部模块都实现相应的生命周期职责，应用启动和销毁的过程，请求沿着指定链条从外到内传递，也可以按需指定跳跃某个模块，这样大大降低了模块之间的耦合，从而更好的管理代码。
- 依赖注入：作为参数传入 A 对象中。这样做的好处是当 B 模块的初始化等条件发生变化时，不必在 A 对象中进行重复的修改。

数据预拉服务：容器是否会命中依赖两个条件，其一对应离线包代码是否下载好；其二对应版本的数据是否已经预拉缓存完毕。

用户进入文档管理首页，首先会去拉取列表索引数据，然后通过列表数据 id 进行文档内容数据做预拉，储存在本地数据库，本地数据库的存储可以参考前端离线化探索。

- webview service：在整个数据预拉的过程，我们是通过一套独立的客户端后台 webview 服务执行具体任务
- 数据快照：对于纯 dom 结构的文档型品类，我们会在打开文档，解析数据后，把生成的 html 缓存在本地数据库一张快照表里。下一次切换容器时，在取本地数据去解析的同时，会判断对应 id 在快照表是否存在缓存，如果有，直接取出来，覆盖在 html 上，用户可以提前看到上一次渲染的数据，等本地数据真正解析完，再展示可交互界面。解析数据准备渲染也是需要一个上百毫秒的过程，这一策略可以让用户提前看到内容。
- 预创建：有了极致的打开速度，如何优化新建速度呢。正常的新建流程是这样的，用户点击新建按钮，前端请求创建 cgi, 等待后台创建成功返回新文档 url，前端再新开 webview，加载展示页面。我们可以看，由于需要等待创建接口返回的原因，到新建的过程比正常打开一个文档还要更久。

怎么样才能让新建也做到秒开呢？思路和数据预拉取一样，在用户进入文档首页的同时，我们会提前预请求一批创建 id，然后缓存到本地，同时根据创建 id 生成一篇空白文档数据，储存在本地，标示状态为未使用。用户点击新建按钮，本质上是从本地取一个未使用的文档 url，直接用容器切换打开，然后再和后台进行同步。

待优化的问题：容器化方案用各种预创建 webview 的方式换取了打开速度，app 内存占用上会比未使用容器化方案要大非常多，webview 的释放时机、预加载数据的策略优化，及从客户端到 web 端，如何更好的做内存管理是接下来需要进一步优化的点。

2. cdn 原理

CDN 是将源站内容分发至最接近用户的节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。

最简单的 CDN 网络由一个 DNS 服务器和几台缓存服务器组成：

- 当用户点击网站页面上的内容 URL，经过本地 DNS 系统解析，DNS 系统会最终将域名的解析权交给 CNAME 指向的 CDN 专用 DNS 服务器。
- CDN 的 DNS 服务器将 CDN 的全局负载均衡设备 IP 地址返回用户。
- 用户向 CDN 的全局负载均衡设备发起内容 URL 访问请求。
- CDN 全局负载均衡设备根据用户 IP 地址，以及用户请求的内容 URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。
- 区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户 IP 地址，判断哪一台服务器距用户最近；根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的 IP 地址。
- 全局负载均衡设备把服务器的 IP 地址返回给用户。
- 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。

cdn 解决的问题：

- 加速网站的访问
- 实现跨运营商、跨地域的全网覆盖
- 保障你的网站安全
- 异地备援
- 节约成本投入
- 让你更专注业务本身

# 果肉教育

## 一面

1. react-lite 少了什么东西？

- 所有 React.PropTypes 方法都是no-op（空函数）
- 在服务器端渲染中使用 React，在浏览器中使用 React-lite
- react-lite 将用新的 dom 树替换 dom 树
- 您最好避免 script|head|link 在客户端标记
- 不能使用 react-dev-tool inspect react-lite，应该切换到常规的 react 进行调试
- react-lite 仅适用于 JSX 工具链（问题）
- 与 react 不同，eventreact-lite 中的对象始终是持久性的，并且 event.persist 设置为 no-op 以避免抛出错误。
- react-lite 无法使用 react-tap-event-plugin，请用 fastclick 代替，或添加别名'react-tap-event-plugin': 'react-lite/lib/react-tap-event-plugin'，就像这里
不能使用 transform-react-inline-elements，您将获得包含 react 和捆绑包 react-lite。
- react-lite 只遵循 React 最佳实践。

2. react hooks 原理

- React 中是通过类似单链表的形式来代替数组的，通过 next 按顺序串联所有的 hook。

```js
type Hooks = {
    memoizedState: any, // 指向当前渲染节点 Fiber
  baseState: any, // 初始化 initialState， 已经每次 dispatch 之后 newState
  baseUpdate: Update<any> | null,// 当前需要更新的 Update ，每次更新完之后，会赋值上一个 update，方便 react 在渲染错误的边缘，数据回溯
  queue: UpdateQueue<any> | null,// UpdateQueue 通过
  next: Hook | null, // link 到下一个 hooks，通过 next 串联每一 hooks
}

type Effect = {
  tag: HookEffectTag, // effectTag 标记当前 hook 作用在 life-cycles 的哪一个阶段
  create: () => mixed, // 初始化 callback
  destroy: (() => mixed) | null, // 卸载 callback
  deps: Array<mixed> | null,
  next: Effect, // 同上 
};
```

- memoizedState，cursor 是存在哪里的？如何和每个函数组件一一对应的？

我们知道，react 会生成一棵组件树（或Fiber 单链表），树中每个节点对应了一个组件，hooks 的数据就作为组件的一个信息，存储在这些节点上，伴随组件一起出生，一起死亡。

3. react hooks 生命周期类似实现方式
4. 后端服务
5. 文件 hash 算法原理？
