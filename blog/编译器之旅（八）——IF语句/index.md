---
title: 编译器之旅（八）——IF语句
date: 2020-3-16 17:22:09
categories:
- 计算机基础
tags: 编译原理, IF语句
path: /tour-of-compiler-if-statements/
---

# 需求

现在我们可以比较值了，是时候在我们的语言中添加 IF 语句了，因此让我们看一下 IF 语句的一般语法以及如何将它们转换为汇编语言。

# 准备

## IF 语法

IF 语句的语法为：

```
if (condition is true) 
  perform this first block of code
else
  perform this other block of code
```

通常如何将其转换为汇编语言？事实证明如果相反的比较成立，我们将执行相反的比较并跳转：

```
       perform the opposite comparison
       jump to L1 if true
       perform the first block of code
       jump to L2
L1:
       perform the other block of code
L2:
```

其中 L1 和 L2 是汇编语言标签。

## 在我们的编译器中生成程序集

现在我们输出代码以基于比较来设置寄存器，例如

```
int x; x= 7 < 9;         From input04
```

变成

```
movq    $7, %r8
movq    $9, %r9
cmpq    %r9, %r8
setl    %r9b        Set if less than 
andq    $255,%r9
```

但是对于IF语句，我们需要进行相反的比较：

```
```

应该变成：

```
```

因此，在这一部分中，我已经实现了IF语句。由于这是一个正在工作的项目，因此我确实必须撤消一些操作并将其重构，作为旅程的一部分。在此过程中，我将尝试介绍所做的更改以及添加的内容。

## 新代币和悬空的其他

我们将需要使用我们的语言的一堆新令牌。我（暂时）也想避免其他问题。为此，我更改了语法，以便所有语句组都用'{'...'}'大括号括起来；我称这种分组为“复合陈述”。我们还需要使用括号（（... ...））来容纳IF表达式，以及关键字if和else。因此，新标记为（中的defs.h）：

```
```

# 核心逻辑

## 扫描令牌

单字符标记应该很明显，我不会给出扫描它们的代码。关键字也应该是很明显的，但我会从给扫描代码 keyword()中scan.c：

```
```

## 新的BNF语法

我们的语法开始变得流行，因此我对其进行了一些重写：

```
```

我省略了的定义true_false_expression，但是在某些时候我们添加了更多运算符时，我会添加它。

请注意IF语句的语法：它是if_head（没有'else'子句），或if_head后跟'else'和a compound_statement。

我已经分离出所有不同的语句类型以拥有自己的非终端名称。而且，以前的statements非终结点现在compound_statement 是非终结点，这要求在语句周围使用'{'...'}'。

这意味着compound_statement头部中的'被'{'...'}'包围，compound_statement'else'关键字之后的任何字符也被包围。因此，如果我们嵌套了IF语句，它们必须看起来像：

```
```

并且每个“其他”都属于哪个“如果”没有任何歧义。这解决了悬而未决的问题。稍后，我将使'{'...'}'为可选。

## 解析复合语句

现在的旧void statements()函数compound_statement()如下所示：

```
```

首先，请注意，代码强制解析器在复合语句的开头与lbrace()匹配，而我们仅在将结尾的'}'与匹配时退出rbrace()。

其次，请注意print_statement()，assignment_statement()和一样 if_statement()都返回AST树compound_statement()。在我们的旧代码中，print_statement()本身调用genAST()来求值表达式，然后调用genprintint()。同样， assignment_statement() 也称为genAST()做作业。

好吧，这意味着我们在这里有AST树，在那儿还有其他树。只生成一个AST树，并调用genAST()一次以为其生成汇编代码是有意义的。

这不是强制性的。例如，SubC只为表达式生成AST。对于语言的结构部分（如语句），SubC像在以前版本的编译器中一样，对代码生成器进行特定的调用。

我现在决定使用解析器为整个输入生成一个AST树。解析输入后，就可以从一棵AST树中生成程序集输出。

稍后，我可能会为每个函数生成一个AST树。后来。

## 解析IF语法

因为我们是递归下降解析器，所以解析IF语句还不错：

```
```

现在，我不想处理类似的输入if (x-2)，因此我已经限制了二进制表达式binexpr()只能具有一个根，该根是六个比较运算符A_EQ，A_NE，A_LT，A_GT，A_LE或A_GE之一。

## 第三胎

我差点把你走走的东西偷偷带走了，没有正确解释。在if_statement()我的最后一行中，我建立了一个AST节点：

```
```

那是三个 AST子树！这里发生了什么？如您所见，IF语句将具有三个子代：

- 评估条件的子树
- 紧随其后的复合语句
- 'else'关键字之后的可选复合语句

因此，我们现在需要具有三个子节点的AST节点结构（在中defs.h）：

```
```

因此，A_IF树如下所示：

```
```

## 胶AST节点

还有一个新的A_GLUE AST节点类型。这是做什么用的？现在，我们用很多语句构建一个AST树，因此我们需要一种将它们粘合在一起的方法。

查看compound_statement()循环代码的结尾：

```
```

每次获得新的子树时，我们会将其粘贴到现有树上。因此，对于此语句序列：

```
```

我们最终得到：

```
```

而且，当我们从左到右先深度遍历树时，这仍然会以正确的顺序生成汇编代码。

## 通用代码生成器

现在我们的AST节点有多个子节点，我们的通用代码生成器将变得更加复杂。另外，对于比较运算符，我们需要知道是否要在IF语句（相反的比较中为跳转）或正则表达式（正常的比较中将寄存器设置为1或0）的一部分中进行比较。

为此，我进行了修改，getAST()以便我们可以传递父AST节点操作：

```
```

### 处理特定的AST节点

genAST()现在，其中的代码必须处理特定的AST节点：

```
```

如果不返回，则继续执行普通的二进制运算符AST节点，但有一个例外：比较节点：

```
```

我将介绍新的功能cgcompare_and_jump()和 cgcompare_and_set()下面。

### 生成IF汇编代码

我们使用特定函数处理A_IF AST节点，并使用一个函数来生成新标签号：

```
```

实际上，代码正在执行以下操作：

```
```

## x86-64代码生成功能

因此，我们现在有了一些新的x86-64代码生成功能。其中一些替代了cgXXX()我们在旅程的最后部分中创建的六个比较功能。

对于正常的比较功能，我们现在传递AST操作以选择相关的x86-64 set指令：

```
```

我还发现了一条x86-64指令movzbq，该指令将一个寄存器中的最低字节移出并将其扩展为适合64位寄存器。我现在正在使用它而不是and $255旧代码中的。

我们需要一个函数来生成标签并跳转到它：

```
```

最后，我们需要一个函数进行比较并根据相反的比较跳转。因此，使用AST比较节点类型，我们进行相反的比较：

```
```

# 运行结果

## 输入

```
```

## 输出

```bash
```

out.s

```
```

# 结论

我们已经使用IF语句在我们的语言中添加了第一个控制结构。在此过程中，我不得不重写一些现有的内容，而且由于我脑子里还没有完整的架构计划，因此将来可能需要重写更多内容。

这段旅程的难处在于，对于IF决策，我们必须执行与对普通比较运算符相反的比较。我的解决方案是通知每个AST节点其父节点的节点类型。比较节点现在可以查看父节点是否为A_IF节点。

我知道Nils Holm在实现SubC时选择了不同的方法，因此您应该查看他的代码，以便看到针对同一问题的不同解决方案。

在编译器编写过程的下一部分中，我们将添加另一个控制结构：WHILE循环。
